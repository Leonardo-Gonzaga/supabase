{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "infinite-list-react-router",
  "type": "registry:block",
  "title": "Infinite List",
  "description": "List component with infinite scrolling capabilities, fetching data from Supabase using a render prop.",
  "dependencies": [
    "lucide-react",
    "@supabase/postgrest-js",
    "@supabase/ssr@latest",
    "@supabase/supabase-js@latest"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/default/blocks/infinite-list/components/infinite-list.tsx",
      "content": "'use client'\n\nimport * as React from 'react'\nimport { cn } from '@/lib/utils'\nimport {\n  useInfiniteQuery,\n  SupabaseFilterBuilder,\n} from '@/registry/default/blocks/infinite-list/hooks/use-infinite-query'\n\ninterface InfiniteListProps<TData> {\n  tableName: string\n  selectQuery?: string\n  pageSize?: number\n  filterBuilder?: (query: SupabaseFilterBuilder) => SupabaseFilterBuilder\n  renderItem: (item: TData, index: number) => React.ReactNode\n  className?: string\n  listClassName?: string\n  renderNoResults?: () => React.ReactNode\n  renderEndMessage?: () => React.ReactNode\n  renderSkeleton?: (count: number) => React.ReactNode\n}\n\nconst DefaultNoResults = () => (\n  <div className=\"text-center text-muted-foreground py-10\">No results.</div>\n)\n\nconst DefaultEndMessage = () => (\n  <div className=\"text-center text-muted-foreground py-4 text-sm\">You&apos;ve reached the end.</div>\n)\n\nexport function InfiniteList<TData>({\n  tableName,\n  selectQuery = '*',\n  pageSize = 20,\n  filterBuilder,\n  renderItem,\n  className,\n  listClassName,\n  renderNoResults = DefaultNoResults,\n  renderEndMessage = DefaultEndMessage,\n  renderSkeleton,\n}: InfiniteListProps<TData>) {\n  const { data, loading, hasMore, fetchNextPage } = useInfiniteQuery<TData>({\n    tableName,\n    selectQuery,\n    pageSize,\n    filterBuilder,\n  })\n\n  // Ref for the scrolling container\n  const scrollContainerRef = React.useRef<HTMLDivElement>(null)\n\n  // Intersection observer logic - target the last rendered *item* or a dedicated sentinel\n  const loadMoreSentinelRef = React.useRef<HTMLDivElement>(null)\n  const observer = React.useRef<IntersectionObserver | null>(null)\n\n  React.useEffect(() => {\n    if (observer.current) observer.current.disconnect()\n\n    observer.current = new IntersectionObserver(\n      (entries) => {\n        if (entries[0].isIntersecting && hasMore && !loading) {\n          fetchNextPage()\n        }\n      },\n      {\n        root: scrollContainerRef.current, // Use the scroll container for scroll detection\n        threshold: 0.1, // Trigger when 10% of the target is visible\n        rootMargin: '0px 0px 100px 0px', // Trigger loading a bit before reaching the end\n      }\n    )\n\n    if (loadMoreSentinelRef.current) {\n      observer.current.observe(loadMoreSentinelRef.current)\n    }\n\n    return () => {\n      if (observer.current) observer.current.disconnect()\n    }\n  }, [loading, hasMore, fetchNextPage])\n\n  return (\n    <div ref={scrollContainerRef} className={cn('relative h-full overflow-auto', className)}>\n      <div className={cn(listClassName)}>\n        {data.length === 0 && !loading && renderNoResults()}\n\n        {data.map((item, index) => (\n          <div key={(item as any)?.id ?? index}>{renderItem(item, index)}</div>\n        ))}\n\n        {loading && renderSkeleton && renderSkeleton(pageSize)}\n\n        <div ref={loadMoreSentinelRef} style={{ height: '1px' }} />\n\n        {!hasMore && data.length > 0 && renderEndMessage()}\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/default/blocks/infinite-list/hooks/use-infinite-query.ts",
      "content": "'use client'\n\nimport { createClient } from '@/registry/default/clients/nextjs/lib/supabase/client'\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport { type PostgrestFilterBuilder as PFB } from '@supabase/postgrest-js'\n\n// Create a more flexible type alias that works with multiple versions\nexport type SupabaseFilterBuilder = PFB<any, any, any, any, any> | PFB<any, any, any>\n\ninterface UseInfiniteQueryProps<TData> {\n  tableName: string\n  selectQuery?: string\n  pageSize?: number\n  filterBuilder?: (query: SupabaseFilterBuilder) => SupabaseFilterBuilder\n}\n\nexport function useInfiniteQuery<TData>({\n  tableName,\n  selectQuery = '*',\n  pageSize = 10,\n  filterBuilder,\n}: UseInfiniteQueryProps<TData>) {\n  const supabase = createClient()\n  const [data, setData] = useState<TData[]>([])\n  const [loading, setLoading] = useState(false)\n  const [hasMore, setHasMore] = useState(true)\n  const [offset, setOffset] = useState(0)\n  const isFetching = useRef(false)\n\n  const fetchNextPage = useCallback(async () => {\n    if (isFetching.current || !hasMore) return\n\n    isFetching.current = true\n    setLoading(true)\n\n    try {\n      let query = supabase.from(tableName).select(selectQuery, { count: 'exact' })\n\n      // Apply filters if filterBuilder is provided\n      if (filterBuilder) {\n        query = filterBuilder(query as unknown as SupabaseFilterBuilder) as any\n      }\n\n      const { data: newData, error, count } = await query.range(offset, offset + pageSize - 1)\n\n      if (error) {\n        console.error('Error fetching data:', error)\n        setHasMore(false) // Stop fetching on error\n        return\n      }\n\n      if (newData) {\n        // The Supabase client might return an error object within the data array on failure for specific rows,\n        // filter those out and ensure the resulting array matches TData[].\n        const validData = newData.filter(\n          (item) => typeof item === 'object' && item !== null && !('error' in item)\n        ) as TData[]\n        setData((prevData) => [...prevData, ...validData] as TData[])\n        const currentTotalFetched = offset + validData.length // Use validData length\n        setOffset(currentTotalFetched)\n        // Check if the *fetched* batch size was less than requested, indicating the end\n        setHasMore(validData.length === pageSize)\n      }\n    } catch (error) {\n      console.error('An unexpected error occurred:', error)\n      setHasMore(false) // Stop fetching on unexpected errors\n    } finally {\n      setLoading(false)\n      isFetching.current = false\n    }\n  }, [tableName, selectQuery, pageSize, offset, hasMore, supabase, filterBuilder])\n\n  // Initial fetch\n  useEffect(() => {\n    // Reset state when props change significantly\n    setData([])\n    setOffset(0)\n    setHasMore(true)\n    // Fetch initial data\n    fetchNextPage()\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [tableName, selectQuery, pageSize, filterBuilder]) // Re-fetch when core props change\n\n  return { data, loading, hasMore, fetchNextPage }\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/default/clients/react-router/lib/supabase/client.ts",
      "content": "/// <reference types=\"vite/types/importMeta.d.ts\" />\nimport { createBrowserClient } from '@supabase/ssr'\n\nexport function createClient() {\n  return createBrowserClient(\n    import.meta.env.VITE_SUPABASE_URL!,\n    import.meta.env.VITE_SUPABASE_ANON_KEY!\n  )\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/default/clients/react-router/lib/supabase/server.ts",
      "content": "import { createServerClient, parseCookieHeader, serializeCookieHeader } from '@supabase/ssr'\n\nexport function createClient(request: Request) {\n  const headers = new Headers()\n\n  const supabase = createServerClient(\n    process.env.VITE_SUPABASE_URL!,\n    process.env.VITE_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return parseCookieHeader(request.headers.get('Cookie') ?? '') as {\n            name: string\n            value: string\n          }[]\n        },\n        setAll(cookiesToSet) {\n          cookiesToSet.forEach(({ name, value, options }) =>\n            headers.append('Set-Cookie', serializeCookieHeader(name, value, options))\n          )\n        },\n      },\n    }\n  )\n\n  return { supabase, headers }\n}\n",
      "type": "registry:lib"
    }
  ]
}