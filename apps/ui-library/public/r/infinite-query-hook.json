{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "infinite-query-hook",
  "type": "registry:block",
  "title": "Infinite Query Hook",
  "description": "React hook for infinite lists, fetching data from Supabase.",
  "dependencies": [
    "@supabase/supabase-js",
    "@supabase/postgrest-js@*"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/default/blocks/infinite-query-hook/hooks/use-infinite-query.ts",
      "content": "'use client'\n\nimport { createClient } from '@/registry/default/fixtures/lib/supabase/client'\nimport { PostgrestQueryBuilder } from '@supabase/postgrest-js'\nimport { SupabaseClient } from '@supabase/supabase-js'\nimport { useCallback, useEffect, useState } from 'react'\n\nconst supabase = createClient()\n\n// The following types are used to make the hook type-safe. It extracts the database type from the supabase client.\ntype SupabaseClientType = typeof supabase\n\n// Utility type to check if the type is any\ntype IfAny<T, Y, N> = 0 extends 1 & T ? Y : N\n\n// Extracts the database type from the supabase client. If the supabase client doesn't have a type, it fallback properly.\ntype Database =\n  SupabaseClientType extends SupabaseClient<infer U>\n    ? IfAny<\n        U,\n        {\n          public: {\n            Tables: Record<string, any>\n            Views: Record<string, any>\n            Functions: Record<string, any>\n          }\n        },\n        U\n      >\n    : never\n\n// Change this to the database schema you want to use\ntype DatabaseSchema = Database['public']\n\n// Extracts the table names from the database type\ntype SupabaseTableName = keyof DatabaseSchema['Tables']\n\n// Extracts the table definition from the database type\ntype SupabaseTableData<T extends SupabaseTableName> = DatabaseSchema['Tables'][T]['Row']\n\ntype SupabaseSelectBuilder<T extends SupabaseTableName> = ReturnType<\n  PostgrestQueryBuilder<DatabaseSchema, DatabaseSchema['Tables'][T], T>['select']\n>\n\n// A function that modifies the query. Can be used to sort, filter, etc. If .range is used, it will be overwritten.\ntype SupabaseQueryHandler<T extends SupabaseTableName> = (\n  query: SupabaseSelectBuilder<T>\n) => SupabaseSelectBuilder<T>\n\ninterface UseInfiniteQueryProps<T extends SupabaseTableName, Query extends string = '*'> {\n  // The table name to query\n  tableName: T\n  // The columns to select, defaults to `*`\n  columns?: string\n  // The number of items to fetch per page, defaults to `20`\n  pageSize?: number\n  // A function that modifies the query. Can be used to sort, filter, etc. If .range is used, it will be overwritten.\n  trailingQuery?: SupabaseQueryHandler<T>\n}\n\n//\nfunction useInfiniteQuery<\n  TData extends SupabaseTableData<T>,\n  T extends SupabaseTableName = SupabaseTableName,\n>({ tableName, columns = '*', pageSize = 20, trailingQuery }: UseInfiniteQueryProps<T>) {\n  const [data, setData] = useState<TData[]>([])\n  const [isLoading, setIsLoading] = useState(false)\n  const [isSuccess, setIsSuccess] = useState(false)\n  const [hasInitialFetch, setHasInitialFetch] = useState(false)\n  const [error, setError] = useState<Error | null>(null)\n  const [count, setCount] = useState<number>(0)\n  const [isFetching, setIsFetching] = useState(false)\n  const hasMore = count && count > data.length\n\n  const fetchPage = useCallback(\n    async (skip: number) => {\n      if (hasInitialFetch && (isFetching || !hasMore)) return\n\n      setIsFetching(true)\n      try {\n        let query = supabase\n          .from(tableName)\n          .select(columns, { count: 'exact' }) as unknown as SupabaseSelectBuilder<T>\n\n        // Apply filters if trailingQuery is provided\n        if (trailingQuery) {\n          query = trailingQuery(query)\n        }\n\n        const { data: newData, count } = await query.range(skip, skip + pageSize - 1).throwOnError()\n\n        if (count) {\n          setCount(count)\n        }\n\n        if (newData) {\n          setData((prevData) => [...prevData, ...newData] as TData[])\n        }\n\n        setIsSuccess(true)\n      } catch (error: any) {\n        console.error('An unexpected error occurred:', error)\n        setError(error)\n      } finally {\n        setIsFetching(false)\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [tableName, columns, pageSize, hasMore]\n  )\n\n  const fetchNextPage = useCallback(async () => {\n    fetchPage(data.length)\n  }, [data.length, fetchPage])\n\n  useEffect(() => {\n    setIsSuccess(false)\n\n    setIsLoading(true)\n    // Reset state when props change significantly\n    setData([])\n    // Fetch initial data\n    fetchNextPage()\n\n    setIsLoading(false)\n    setHasInitialFetch(true)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [tableName, columns, pageSize])\n\n  return { data, isSuccess, isLoading, isFetching, error, hasMore, fetchNextPage, count }\n}\n\nexport {\n  useInfiniteQuery,\n  type SupabaseQueryHandler,\n  type SupabaseTableData,\n  type SupabaseTableName,\n  type UseInfiniteQueryProps,\n}\n",
      "type": "registry:hook"
    }
  ]
}